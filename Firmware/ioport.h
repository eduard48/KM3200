#ifndef _IOPORT_													//Защита от повторного включения файла
#define _IOPORT_

#include <avr/io.h>												//Стандартная библиотека ввода/вывода
#include <util/delay.h>											//Стандартная библиотека временных задержек
#include <avr/interrupt.h>										//Стандартная библиотека обработки прерываний

#include "km_3200.h"										// Загрузить заголовок

#ifndef F_CPU
#warning "F_CPU not defined. Frequency by default 14.7456MHz"
#define F_CPU 14745600UL		/*Стандартная константа задающая частоту микроконтроллера (необходима для корректной работы функций задержек)*/
#endif

// === Объявляю структуру для счетных входов
typedef struct
{
	unsigned char stat;			// Состояние памяти предыдущего цикла
	unsigned int pre_cnt1;			// Предделитель счетчика №1
	unsigned long int cnt1;			// Значение счетчика №1
	unsigned int pre_cnt2;			// Предделитель счетчика №2
	unsigned long int cnt2;			// Значение счетчика №2
	unsigned int pre_cnt3;			// Предделитель счетчика №3
	unsigned long int cnt3;			// Значение счетчика №3
} counters;

counters count;			// === Объявление рабочей структуры для счетчиков ===

//=========================== Фукция инициализации портов входа/выхода ====================
void InitLine(void)
{
	// --- настраиваю входы/выходы для контроллера КМ01-8600.М ---
	PORTB = 0x00;		// на выходах LD, DO1, DO2 д.б. 0
	DDRB  = 0x07;		// Выводы DO1, DO2, LD -выходы
	PORTC = 0x00;		// на выходах - 0
	DDRC  = 0x00;		// Выводы  DI1...DI3 -входы
	PORTD = 0x21;		// подтягиваем к + JP1,RX
	DDRD  = 0x06;		// Выводы  JP1 - вход, TXE и TX - выходы
}

/*******************************************************************************
* Функция настройки внутренних устройств контроллера
********************************************************************************/
void InitDev(void)
{
	// --- настраиваю прерывания по изменению состояния входов ---
	PCICR |= (1<<PCIE1);								// Разрешение прерывания для группы PCINT8...PCINT15 (PORTC)
	PCMSK1 |= (0<<PCINT7) | (0<<PCINT6) | (0<<PCINT5) | (0<<PCINT4) | (0<<PCINT3) | (1<<PCINT2) | (1<<PCINT1) | (1<<PCINT0); // Разрешить прерывания PCINT8,PCINT9,PCINT10
}

//=============================================== РАБОТА С ЛИНИЯМИ ВВОДА/ВЫВОДА ===================================================
//=================================================================================================================================
//=========================== Функция чтения состояния входов =====================================================================
//Функция принимает в качестве параметров: port_line - Линия ввода/вывода (от 0 до maxAddr_DI)
//Функция возвращает: Состояние линии (0x01-высокий уровень/0x00-низкий уровень/0xFF-не верный номер линии)
// считывает состояние только одной линии входа
//=================================================================================================================================
char InState(unsigned char port_line)
{
//------------------------ Для контроллера КМ3200 ---------------------------------
	if(port_line < maxAddr_DI) {return ((MB_Ireg[1] >> port_line) & 0x01);}	// Чтение состояния входов и возврат с полученным значением
	else return 0xFF;															// вернуться с ошибкой
}

//=========================== Функция чтения состояния выходов =============================
//Функция принимает в качестве параметров: port_line - Линия вывода (от 0 до maxAddr_DO)
//Функция возвращает: Состояние линии (0x01-высокий уровень/0x00-низкий уровень/0xFF-не верный номер линии)
// считывает состояние только одной линии входа
//=========================================================================================
char OutState(unsigned char port_line)
{
//------------------------ Для контроллера КМ3200 ---------------------------------
	if(port_line < maxAddr_DO) {return ((MB_Ireg[2] >> port_line) & 0x01);}	// Чтение состояния выходов и возврат с полученным значением
	else return 0xFF;														// вернуться с ошибкой	
}

//========================== Функция установки цифровых выходов ===========================
//Функция принимает в качестве параметров:
//port_line - Линия ввода/вывода (от 0 до maxAddr_DO)
//level     - Устанавливаемый уровень (0 - низкий/1-высокий)
//Функция возвращает:
//0x00-если указан корректный номер линии, в противном случае 0xFF
//=========================================================================================

char OutControl(char port_line, char level)
{
//------------------- Для контроллера КМ3200 --------------------
	if ((port_line >= maxAddr_DO) || (level > 1) ) return 0xFF;	//Если указана не существующая линия порта или не верный уровень сигнала, выход с ошибкой
	if (level!=0x00) {MB_Hreg[5] |= (0x01 << port_line);	return 0x01;} //Установка состояния линии в 1
	else { MB_Hreg[5] &= ~(0x01 << port_line);}			//Установка состояния линии в 0
	return 0;
}

//=========================================================== КОНТРОЛЬ СОСТОЯНИЯ ДИСКРЕТНЫХ ЛИНИЙ ВВОДА ==================================================
//========================================================================================================================================================
// --- Чтение состояния входов (надо при старте, т.к. дальнейшие изменения состояния работают по прерыванию) ---
void INP_Read(void)
{
	for(char i=0;i<3;i++) // считывает состояние 3 бит
	{
		if((PINC & (1<<i)) == 0) MB_Ireg[1] &= ~(1<<(2-i));// установить бит в 0
		else MB_Ireg[1] |= (1<<(2-i));						// установить бит в 1
	}
}
 /******************************************************************************
 * Обработка прерывания по изменению состояния входов DI1,DI2,DI3,DI4,DI5,DI6,DI7
 ******************************************************************************/
 ISR(PCINT1_vect)
{ // пишем текущее состояние входов в регистр Input
char i;
	for(i=0;i<3;i++) // считывает состояние 3 бит
		{
		if((PINC & (1<<i)) == 0) MB_Ireg[1] &= ~(1<<(2-i));// установить бит в 0
		else MB_Ireg[1] |= (1<<(2-i));						// установить бит в 1
		}
// Проверяем работу счетных входов!
// =========== если задана работа счетного входа №1 ============================
if((MB_Hreg[6] & 0x01) != 0)
{
	if(((PINC & 0x04) != 0) & ((count.stat & 0x01) == 0)) // если на входе 1, а был 0
	{
		count.pre_cnt1++;		// увеличить предделитель на 1
		count.stat |= 0x01;		// защита от повторного входа
		if(count.pre_cnt1 >= MB_Hreg[7]) {count.pre_cnt1 = 0; count.cnt1++;} // собственно счет
	}
	if((PINC & 0x04) == 0) count.stat &= ~(0x01); // Если на входе 0 - взвести счетчик и ждать очередной 1!
}
// ================ если задана работа счетного входа №2 =============================================
if((MB_Hreg[6] & 0x02) != 0)
{
	if(((PINC & 0x02) != 0) & ((count.stat & 0x02) == 0)) // если на входе 1, а был 0
	{
		count.pre_cnt2++;		// увеличить предделитель на 1
		count.stat |= 0x02;		// защита от повторного входа
		if(count.pre_cnt2 >= MB_Hreg[10]) {count.pre_cnt2 = 0; count.cnt2++;} // собственно счет
	}
	if((PINC & 0x02) == 0) count.stat &= ~(0x02); // Если на входе 0 - взвести счетчик и ждать очередной 1!
}
// ================ если задана работа счетного входа №3 =============================================
if((MB_Hreg[6] & 0x04) != 0)
{
	if(((PINC & 0x01) != 0) & ((count.stat & 0x04) == 0)) // если на входе 1, а был 0
	{
		count.pre_cnt3++;			// увеличить предделитель на 1
		count.stat |= 0x04;			// защита от повторного входа
		if(count.pre_cnt3 >= MB_Hreg[13]) {count.pre_cnt3 = 0; count.cnt3++;} // собственно счет
	}
	if((PINC & 0x01) == 0) count.stat &= ~(0x04); // Если на входе 0 - взвести счетчик и ждать очередной 1!
}
} 

//======================================================== РАБОТА С ВЫХОДАМИ =============================================================
//========================================================================================================================================
/*******************************************************************************
*	Функция чтения состояния выходов
********************************************************************************/
void OUT_Read(void)
{
	char i;
	// --- Чтение состояния выходов ---
	for(i=0;i<2;i++) // только 2 выхода
	{
		if((PINB & (1<<(1+i))) == 0) MB_Ireg[2] &=~(0x01 << i);	// установить 0
		else MB_Ireg[2] |=0x01 << i;							// установить 1
	}
}

/*******************************************************************************
*	Функция обновления состояния выходов (работа из основной программы)
********************************************************************************/
void OUT_Update(void)
{
char i;
	// --- Изменение состояния выходов ---
	for(i=0;i<2;i++) // первые 4 выхода (реле)
	{
		if((MB_Hreg[5] & (1<<i)) == 0) PORTB&=~(0x01 << (1+i));	// установить 0
		else PORTB|=0x01 << (1+i);								// установить 1
	}
}

//================================================ РАБОТА СЧЕТНЫХ ВХОДОВ ==================================================================
//=========================================================================================================================================
// === Очистить счетные регистры ===
void CNT_clear(void)
{
count.stat = 0;
count.pre_cnt1 = 0;
count.cnt1 = 0;
count.pre_cnt2 = 0;
count.cnt2 = 0;
count.pre_cnt3 = 0;
count.cnt3 = 0;
}

// === Перенос значений счетных регистров в регистры INPUT ===
void rd_cnt(void)
{
unsigned long int c = 0;									// Рабочая переменная
  c = count.cnt1 + (((unsigned long int)MB_Hreg[10] << 16) + MB_Hreg[11]);	// коррекция значения счетчика №1
  MB_Ireg[11] = (c >> 16) & 0xFFFF;							// запись старшего числа счетчика №1
  MB_Ireg[12] = c & 0xFFFF;									// запись младшего числа счетчика №1
  c = 0;
  c = count.cnt2 + (((unsigned long int)MB_Hreg[12] << 16) + MB_Hreg[13]);	// коррекция значения счетчика №2
  MB_Ireg[13] = (c >> 16) & 0xFFFF;							// запись старшего числа счетчика №2
  MB_Ireg[14] = c & 0xFFFF;									// запись младшего числа счетчика №2
  c = 0;
  c = count.cnt3 + (((unsigned long int)MB_Hreg[14] << 16) + MB_Hreg[15]);	// коррекция значения счетчика №3
  MB_Ireg[15] = (c >> 16) & 0xFFFF;							// запись старшего числа счетчика №3
  MB_Ireg[16] = c & 0xFFFF;									// запись младшего числа счетчика №3
}

#endif
//************************************************** END ***********************************************************************************