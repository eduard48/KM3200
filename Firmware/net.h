/*****************************************************************************************************************
* Здесь для приема пакета ModBus использую прерывания таймера0.
******************************************************************************************************************/
#ifndef _NET_										//Защита от повторного включения файла
#define _NET_

#include <avr/io.h>								//Стандартная библиотека ввода/вывода
#include <avr/interrupt.h>						//Библиотека обработки прерываний
#include <util/delay.h>							//Стандартная библиотека временных задержек

#ifndef F_CPU
# warning "F_CPU not defined. Frequency by default 14.7456MHz"
#define F_CPU 14745600UL							/*Стандартная константа задающая частоту микроконтроллера (необходима для корректной работы функций задержек)*/
#endif

#include "ioport.h"
#include "mem.h"

#ifndef COM_RX_BUFFER_SIZE
# warning "COM_RX_BUFFER_SIZE not defined. Value will be set by default 64 bytes"
#define COM_RX_BUFFER_SIZE 64						/*Длина приемного буфера*/
#endif
#ifndef COM_TX_BUFFER_SIZE
# warning "COM_TX_BUFFER_SIZE not defined. Value will be set by default 64 bytes"
#define COM_TX_BUFFER_SIZE 64						/*Длина передающего буфера*/
#endif


//---------------------------- Работа с сетью RS485 ---------------------------
// --------------------- Для контроллера типа КМ01-8600.М ---------------------
#define NET_DDR               DDRD
#define NET_PIN               PIND
#define NET_PORT              PORTD
#define NET_RX                0x00
#define NET_TX                0x01
#define NET_TXE               0x02

#define NET_UBRRH             UBRR0H
#define NET_UBRRL             UBRR0L
#define NET_UCSRA             UCSR0A
#define NET_UCSRB             UCSR0B
#define NET_UCSRC             UCSR0C
#define NET_UDR               UDR0

//---------------------------- Работа с протоколом ModBus ---------------------
char _Frame_pause;								//Флаг превышения интервала 1.5 символа в Modbus RTU (1-интервал превышен/0-превышения не было)

char _UART_RX_Buf[COM_RX_BUFFER_SIZE];	//Приемный буфер UART
char _UART_RX_dup[COM_RX_BUFFER_SIZE];	//Копия приемного буфера UART
int _UART_RX_point;						//Текущая позиция в приемном буфере UART
char _UART_RX_length;					//Длина принятой посылки по UART
char _UART_RX_end;						//Признак окончания принятой посылки по UART

char _UART_TX_Buf[COM_TX_BUFFER_SIZE];	//Передающий буфер UART
int _UART_TX_point;						//Текущая позиция в передающем буфере UART
char _UART_TX_length;					//Длинна отправляемой посылки по UART
char _UART_TX_end;						//Признак окончания передачи по UART

// ********************** Определю используемые внутренние переменные для протокола MODBUS RTU *********************************
unsigned char m_coderr;	// Содержит код ошибки
char Func;				//Код функции (Func) Содержит выполняемую команду
int SubFunc;			//Код подфункции (SubFunc) Начальный адрес регистрового поля из запроса
int Data;				//Регистр данных (Data) Кол-во запрашиваемых квантов (регистров или выводов)

//-------------------------------------
void MODBUS_RTU(void);
//-------------------------------------
//======================== Прерывание по совпадению А таймера 0 ============================
// === пакет принят ===
//------------------------------------------------------------------------------------------
SIGNAL(TIMER0_COMPA_vect)
{
	int temp;														//Вспомогательная переменная
	
	_Frame_pause=0;													//Обнуление флага превышения интервала 1.5 символа
	for (temp=0; temp<_UART_RX_point; temp++) _UART_RX_dup[temp]=_UART_RX_Buf[temp];//Копирование приемного буфера
	_UART_RX_length=_UART_RX_point;								    //Вычисление длины принятой посылки
	_UART_RX_point=0;										        //Указатель приемного буфера на начало
	TCCR0A=0x00;													//Остановка таймера
	TCCR0B=0x00;													//Остановка таймера
	_UART_RX_end=1;
//	LD_on;										// вкл светодиод
}

//------------------------------------------------------------------------------------------
//======================== Прерывание по совпадению B таймера 0 ============================
//------------------------------------------------------------------------------------------
SIGNAL(TIMER0_COMPB_vect)
{
	_Frame_pause=1;														//Установить флаг превышения интервала 1.5 символа
}

//================================== Функция расчета контрольной суммы в протоколе Modbus RTU ====================================
//Функция принимает:
//*buf-указатель на массив в котором содержатся данные для расчета контрольной суммы
//Len-количество байт участвующих в расчете контрольной суммы
int _CRC_calc(char *buf, char Len)
{
	unsigned int CRC;														//Переменная для расчета контрольной суммы
	char temp,temp2;														//Вспомогательные переменные
	
	CRC=0xFFFF;																//Начальное значение CRC (по алгоритму расчета CRC)
	for (temp=0; temp<Len; temp++)											//Цикл для всех байт участвующих в расчете
	{
		CRC=CRC^*buf;														//"Исключающее или" (по алгоритму расчета CRC)
		buf++;																//Указатель на следующий байт
		for (temp2=0; temp2<8; temp2++)										//Цикл для каждого бита в байте
		if ((CRC & 0x0001)==0) CRC=CRC>>1;									//Если младший бит в единице, просто сдвиг (по алгоритму расчета CRC)
		else
		{
			CRC=CRC>>1;														//Сдвиг	и "Исключающее или" (по алгоритму расчета CRC)
			CRC=CRC^0xA001;													//Полином для "Исключающего или" 1010 0000 0000 0001
		}
	}
	
	return CRC;																//Возврат расчитанной контрольной суммы
}

/****************************************************************************************************************************************
Name:         void NetRxChar(void)
Description:  Ф-я вызывается по прерыванию - если принят байт в буфер UDR(прием завершен)
Output:       Data in NetRxData[]
new:		Принимаю весь пакет и ввожу дополнительную функцию проверки принятого пакета по ModBus
*****************************************************************************************************************************************/
ISR(USART_RX_vect)
{
	unsigned char InByte; // Рабочий буфер - для принятого байта

	if (NET_UCSRA & ((1<<FE0)+(1<<DOR0))) {InByte = NET_UDR; return;} // При ошибке кадрирования и переполнении буфера
	InByte = NET_UDR;												//Чтение регистра приемника
	if (_Frame_pause==0)                                            //Если было превышение интервала 1.5 символа
	{
		_UART_RX_Buf[_UART_RX_point]=InByte;						//Записываю принятое в буфер
		TIFR0|=(1<<OCF0A)|(1<<OCF0B);                               //Обнуление флага прерывания по таймеру (необходимо если прерывание возникло в момент выполнения данного обработчика)
		TCNT0=0;                                                    //Обнуление счетного регистра таймера
		TCCR0A=(1<<WGM01);											// Установка режима работы таймера "Сброс при совпадении"
		TCCR0B=(1<<CS02);											//Установка коэффициента деления тактовой частоты 256
		_UART_RX_point++;                                           //Увеличение счетчика принятых байт
		if (_UART_RX_point>=(COM_RX_BUFFER_SIZE-1)) _UART_RX_point=0; //Защита от длинной бессмысленной команды
	}
	// Управление светодиодом
//	if((_UART_RX_point == 1) && (InByte == (Address_device & 0xFF))) LD_off;	// выкл светодиод если первый байт = адресу
}

//=========================================== Функция инициализации COM порта ============================================================
//Функция принимает в качестве параметров:
//COM_speed - Табличное значение скорости COM порта
//COM_param - Табличное значение параметров COM порта
//Функция возвращает:
//0x00-если все параметры заданы корректно, в противном случае 0xFF
//========================================================================================================================================
char COM_Init(char COM_speed,char COM_param)
{
	unsigned char m;
	float temp;
	long Speed;
	switch (COM_speed)
		{
			case 0x03: Speed=1200; break;
			case 0x04: Speed=2400; break;
			case 0x05: Speed=4800; break;
			case 0x06: Speed=9600; break;
			case 0x07: Speed=19200; break;
			case 0x08: Speed=38400; break;
			case 0x09: Speed=57600; break;
			case 0x0A: Speed=115200; break;
			default: {Speed=9600;}
		}
	
	if ((Speed<=0) || (Speed>1000000)) return 0xFF;					//Если не верно задана скорость
	
	temp=(float)F_CPU/Speed/16-0.5;									//Расчет значения регистра скорости UART
	if (temp>=0.5)													//Если скорость допустимая для данного кварца
	{
			NET_UBRRH =(unsigned long)temp>>8;
			NET_UBRRL =(unsigned long)temp & 0x000000FF;
	}
	else return 0xFF;												//иначе, выход с ошибкой

	switch (COM_param)
		{
			case 0x01: NET_UCSRC = (1<<UMSEL01)+(1<<UPM01)+(1<<USBS0)+(1<<UCSZ01)+(1<<UCSZ00); break;	// 8 bit, 2 стоп бита, event(8E2)
			case 0x02: NET_UCSRC = (1<<UMSEL01)+(1<<UCSZ01)+(1<<UCSZ00); break;							// 8 bit, 1 стоп бита, none (8N1)
			case 0x03: NET_UCSRC = (1<<UMSEL01)+(1<<USBS0)+(1<<UCSZ01)+(1<<UCSZ00); break;				// 8 bit, 2 стоп бита, none (8N2)
			default:   NET_UCSRC = (1<<UMSEL01)+(1<<UPM01)+(1<<UCSZ01)+(1<<UCSZ00);						// 8 bit, 1 стоп бита, event(8E1)
		}
	NET_UCSRB=(1<<RXCIE0)|(1<<RXEN0)|(1<<TXEN0)|(1<<TXCIE0);	//Настройка приемо-передатчика(разрешить RX, TX и прерывания)
		
	m = NET_UDR; // Считать и очичтить от барахла!!! Иначе подвисает))))
	m = NET_UDR; // Считать и очичтить от барахла!!! Иначе подвисает))))
	m = NET_UDR; // Считать и очичтить от барахла!!! Иначе подвисает))))
	m = NET_UDR; // Считать и очичтить от барахла!!! Иначе подвисает))))
	
	// --- Настройка выводов контроллера для работы с RS485 ---
	NET_PORT&=~(1<<NET_TX);									// на TX - выходе - 0
	NET_DDR|=(1<<NET_TX);									// вывод TX - выход
	NET_PORT|=(1<<NET_RX);									// RX - подтянут к +
	NET_DDR&=~(1<<NET_RX);									// Вывод RX - вход
	NET_PORT&=~(1<<NET_TXE);								// Переключить UART0 на прием, на RXE - 0
	NET_DDR|=(1<<NET_TXE);									// Настройка линии управления драйвером RS485, вывод RXE - выход
		
	// Очистить рабочие буфера
	for(m=0;m<COM_RX_BUFFER_SIZE;m++) {_UART_RX_Buf[m] = 0;}
	for(m=0;m<COM_RX_BUFFER_SIZE;m++) {_UART_RX_dup[m] = 0;}
	for(m=0;m<COM_TX_BUFFER_SIZE;m++) {_UART_TX_Buf[m] = 0;}
	
	_UART_RX_point=0;										//Указатель на начало буфера
	_UART_RX_end=0;											//Сбросить признак окончания приема
	_UART_TX_end=1;											//Установить флаг завершения предачи
		
	// Настраиваю работу таймера0
	if (Speed>=19200) Speed=19200;							//Если значение скорости 19200 бит/сек или больше, длительность тишины равна 1.75 мс.
	OCR0A=35*(float)F_CPU/Speed/256+0.5;					//Расчет длительности 3.5 символов
	OCR0B=15*(float)F_CPU/Speed/256+0.5;					//Расчет длительности 1.5 символов
	TIMSK0|=(1<<OCIE0A)|(1<<OCIE0B);						//Разрешение прерывание по совпадению А и B таймера 0
	return 0;
}

//================================================= Функции записи в COM порт ===============================================================
//========================================= Функция запуска передачи информации по UART =====================================================
//Функция принимает в качестве параметров:
//Len - Длина передаваемых данных

void _UART_Go(int Len)
{
//	LD_on;													// Вкл светодиод
	_UART_TX_length=Len;									//Длина передаваемых данных
	_UART_TX_point=0;										//Позиция в передающем буфере
	_UART_TX_end=0;											//Сброс флага окончания передачи (отправка новой посылки)
	NET_UCSRB |= (1<<UDRIE0); 								// Разрешить прерывание при очистке буфера
	NET_PORT |= (1 << NET_TXE);								// Активизировать передачу по RS485
}
/********************************************************************************************************************************************
Name:         void NetTxByte(void)
Description:  Ф-я вызывается по прерыванию - буфер UDR пуст
*********************************************************************************************************************************************/
ISR(USART_UDRE_vect)
{
  if (_UART_TX_point!=_UART_TX_length)			// если отправлена не вся посылка
  {
    asm("wdr");
    NET_PORT |= NET_TXE;						// Активизировать передачу
    NET_UDR = _UART_TX_Buf[_UART_TX_point];		//Отправка байта по UART
    _UART_TX_point++;							// Увеличить указатель
  }
  else NET_UCSRB &= ~(1<<UDRIE0);  /* Запретить прерывания TX если вся посылка передана*/
}

/********************************************************************************************************************************************
Description:  Ф-я вызывается по прерыванию - передача завершена
              TxBuffer были переданы в NET.
*********************************************************************************************************************************************/
ISR(USART_TX_vect)
{
//  LD_off;							// Выкл светодиод
  NET_PORT &= ~(1 << NET_TXE);		// Переключить в режим приема RS485
  _UART_TX_end=1;					//Установить флаг завершения передачи
}

/************************************* Функция чтения принятой посылки в протоколе Modbus RTU *****************************************
* Функция принимает: void
* Функция возвращает:
* 	0x00-если приемный буфер UART пуст;
* 	0x01-данные из приемного буфера UART перемещены в буфер для чтения;
* 	0x80-Не соответствие протоколов (Выбран протокол DCON);
* 	0xFF-не совпадение контрольной суммы принятых данных.
* Функция заносит считанные данные в массив, адрес которого указан в качестве входного параметра.
* Два байта контрольной суммы включены в данный массив.
* Нулевой элемент выходного массива содержит количество прочитаных байт, считая байты контрольной суммы.
****************************************************************************************************************************************/

char Read_Modbus(void)
{
	unsigned int CRC;									//Переменная для контрольной суммы
	
	if (_UART_RX_end==0) return 0;						//Выход если признак окончания приема пакета не установлен
	_UART_RX_end=0;										//Сброс флага окончания приема
	if(_UART_RX_Buf[0] != Address_device) return 0xFD;	// если адрес не наш
	if(_UART_RX_length<=5) return 0xFE;
	CRC=_CRC_calc(_UART_RX_Buf,_UART_RX_length-2);		//Расчет CRC
	// Проверка контрольной суммы, если полученая и вычисленная CRC16 не совпадают
	if (((CRC>>8)!=_UART_RX_Buf[_UART_RX_length-1]) || ((CRC & 0xFF)!=_UART_RX_Buf[_UART_RX_length-2])) return 0xFF; // Возврат с ошибкой CRC

	return 1;
}

//======================================================================================================================================================================
//																	MODBUS RTU
//======================================================================================================================================================================

/*****************************************************************************
 Чтение состояния дискретных выходов DO и дискретных входов DI
******************************************************************************
*****************************************************************************/
void MODBUS_K1_2(void)
{
//unsigned int n;
int n;
unsigned char b,d,nb,c;
asm("wdr");
d = SubFunc + Data;
n = 0;
// Считаем кол-во запрошеных байт
nb = Data/8;
if(Data%8 > 0) nb += 1; // если есть остаток - увеличиваем до целого байта

if(Func == 1) // ---------------- Если надо считать состояние DO -----------------------------
  {
  if(d > maxAddr_DO) {m_coderr=2; return;} // Если запрашивается больше имеющихся DO
  for(b = SubFunc,c = 0; b < d; b++) // заполняем запрошеными данными переменную n
    {
	if(OutState(b) != 0) n|=(0x01 << c); // Если считываемый бит не = 0 - Установим соответствующий бит в переменной
	c++;
	}
  }
else 			  // ----------------- Если надо считать состояние DI -----------------------------
  {
  if(d > maxAddr_DI) {m_coderr=2; return;} // Если запрашивается больше имеющихся DI
  for(b = SubFunc,c = 0; b < d; b++) // заполняем запрошеными данными переменную n
    {
	if(InState(b) != 0) n|=(0x01 << c); // Если считываемый бит не = 0 - Установим соответствующий бит в переменной
	c++;
	}
  }
// =================================== Теперь составим ответ =============================
 b = 0;										// Обнуляем указатель
 _UART_TX_Buf[b++] = Address_device & 0xFF; // Запишем адрес контроллера
 _UART_TX_Buf[b++] = Func; 					// Запишем выполненую команду
 _UART_TX_Buf[b++] =  nb;					// Запишем кол- во отсылаемых байт
 _UART_TX_Buf[b++] = n & 0xFF; 	   			// 1 байт в любом случае
 if(nb == 2) _UART_TX_Buf[b++] = ((n >> 8) & 0xFF); // 2 байт - если надо
 // --------------- Подсчет CRC -------------------
 n = _CRC_calc(_UART_TX_Buf, b);				// Считаем CRC
 _UART_TX_Buf[b++] = n & 0xFF;	  			// Пишем младший байт - вначале передаем младший байт
 _UART_TX_Buf[b++] = ((n >> 8) & 0xFF);		// Пишем старший байт 

 _UART_TX_length = b;	  	  		 // Запишем кол - во передаваемых байт из буфера
}

/*****************************************************************************
 Чтение нескольких Holding или Input регистров (чтение)
******************************************************************************
*****************************************************************************/
void MODBUS_K3_4(void)
{
// Внутренние переменные
unsigned int n;
unsigned char m,b,d;
asm("wdr");
d = SubFunc + Data;
b = 0;

// Составляем ответ
 _UART_TX_Buf[b++] = Address_device & 0xFF; // Запишем адрес контроллера
 _UART_TX_Buf[b++] = Func; 					// Запишем выполненую команду
 _UART_TX_Buf[b++] = (Data<<1) & 0xFF;		// Кол-во байт = кол-во слов*2 и наложить маску
// Считаем смещение
if(Func == 3) // Если надо считать HOLDING регистры
  {
  if(d > maxAddrRegHOLD) {m_coderr=2; return;} // Ошибка!!! запрашивается больше имеющихся
  for(m = SubFunc; m < d; m++) // заполняем запрошеными данными буфер ответа
   {
   _UART_TX_Buf[b++] = (MB_Hreg[m] >> 8) & 0xFF; // Записываем старший байт
   _UART_TX_Buf[b++] =  MB_Hreg[m] & 0xFF;  	 // Записываем младший байт
   }
  }
else 			  // Если надо считать INPUT регистры
  {
  if(d > maxAddrRegINP) {m_coderr=2; return;} // Ошибка!!! запрашивается больше имеющихся
  for(m = SubFunc; m < d; m++) // заполняем запрошеными данными буфер ответа
   {
   _UART_TX_Buf[b++] = (MB_Ireg[m] >> 8) & 0xFF; // Записываем старший байт
   _UART_TX_Buf[b++] =  MB_Ireg[m] & 0xFF;  	   // Записываем младший байт
   }
  }
// --- Подсчет CRC ---
 n = _CRC_calc(_UART_TX_Buf,b);				// Считаем CRC
 _UART_TX_Buf[b++] = n & 0xFF;	  			// Пишем младший байт - вначале передаем младший байт
 _UART_TX_Buf[b++] = ((n >> 8) & 0xFF);		// Пишем старший байт - затем старший байт

 _UART_TX_length = b;	  	  		 // Запишем кол - во передаваемых байт из буфера
}

/*****************************************************************************
 Установка еденичного выхода DO
******************************************************************************
*****************************************************************************/
void MODBUS_K5(void)
{
unsigned int n;
unsigned char b,d;
asm("wdr");
d = SubFunc + Data;
n = 0;
if(d > maxAddr_DO) {m_coderr=2; return;} // Если запрашивается больше имеющихся
// Всегда установка 1 выхода DO
if((_UART_RX_dup[4] == 0xFF) && (_UART_RX_dup[5] == 0x00)) OutControl(SubFunc,1);      // Если установить (вкл выход)
else if((_UART_RX_dup[4] == 0x00) && (_UART_RX_dup[5] == 0x00)) OutControl(SubFunc,0);	// Если сбросить (выкл выход)
else {m_coderr=3; return;} // Если неверно задано поле данных
// *************** Теперь составим ответ **********************************
b = 0;
 _UART_TX_Buf[b++] = Address_device & 0xFF;   		// Запишем адрес контроллера
 _UART_TX_Buf[b++] = Func; 		   					// Запишем выполненую команду
 _UART_TX_Buf[b++] = _UART_RX_dup[2];				// Запишем ст. байт адреса
 _UART_TX_Buf[b++] = _UART_RX_dup[3]; 	   	   		// Запишем мл. байт адреса
 _UART_TX_Buf[b++] = _UART_RX_dup[4];				// Запишем ст. байт данных
 _UART_TX_Buf[b++] = _UART_RX_dup[5]; 	   	   		// Запишем мл. байт данных
// ---- Подсчет CRC ----
 n = _CRC_calc(_UART_TX_Buf,b);				// Считаем CRC
 _UART_TX_Buf[b++] = n & 0xFF;	  		 // Пишем младший байт - вначале передаем младший байт
 _UART_TX_Buf[b++] = ((n >> 8) & 0xFF); // Пишем старший байт - затем старший байт

_UART_TX_length = b;	  	  		 // Запишем кол - во передаваемых байт из буфера
}

/*****************************************************************************
Запись в один регистр Holding 
******************************************************************************
*****************************************************************************/
void MODBUS_K6(void)
{
unsigned int n;
unsigned char b;
asm("wdr");
n = 0;
if(SubFunc > maxAddrRegHOLD) {m_coderr=2; return;} // Если запрашивается изменение регистра больше имеющихся

MB_Hreg[SubFunc] = (_UART_RX_dup[4] << 8) | _UART_RX_dup[5]; // Просто записываем в Holding регистр по указанному адресу
// --- Для контроллера КМ01-3200.М ---
#ifdef _KM3200_
if(SubFunc == 6) wr_mcnt();	// если это конфигурация счетчиков - записать новое значение в EEPROM
else if(SubFunc == 7) wr_vcnt1();	// если это значение делителя для счетчика №1 - записать новое значение в EEPROM
else if(SubFunc == 8) wr_vcnt2();	// если это значение делителя для счетчика №2 - записать новое значение в EEPROM
else if(SubFunc == 9) wr_vcnt3();	// если это значение делителя для счетчика №3 - записать новое значение в EEPROM
else if(SubFunc == 10) wr_vhcnt1();	// если это старшее опорное слово для счетчика №1 - записать новое значение в EEPROM
else if(SubFunc == 11) wr_vlcnt1();	// если это младшее опорное слово для счетчика №1 - записать новое значение в EEPROM
else if(SubFunc == 12) wr_vhcnt2();	// если это старшее опорное слово для счетчика №2 - записать новое значение в EEPROM
else if(SubFunc == 13) wr_vlcnt2();	// если это младшее опорное слово для счетчика №2 - записать новое значение в EEPROM
else if(SubFunc == 14) wr_vhcnt3();	// если это старшее опорное слово для счетчика №3 - записать новое значение в EEPROM
else if(SubFunc == 15) wr_vlcnt3();	// если это младшее опорное слово для счетчика №3 - записать новое значение в EEPROM
else if(SubFunc == 29) wr_adr();	// если это адрес контроллера - записать новое значение в EEPROM
else if(SubFunc == 30) wr_par();	// если это параметры сети - записать новое значение в EEPROM
#endif

// *************** Теперь составим ответ **********************************
b = 0;
 _UART_TX_Buf[b++] = Address_device & 0xFF;			// Запишем адрес контроллера
 _UART_TX_Buf[b++] = Func; 		   					// Запишем выполненую команду
 _UART_TX_Buf[b++] = _UART_RX_dup[2];				// Запишем ст. байт начального адреса регистра
 _UART_TX_Buf[b++] = _UART_RX_dup[3]; 	   	   		// Запишем мл. байт начального адреса регистра
 _UART_TX_Buf[b++] = _UART_RX_dup[4];				// Запишем ст. байт данных регистра
 _UART_TX_Buf[b++] = _UART_RX_dup[5]; 	   	   		// Запишем мл. байт данных регистра
// ---- Кол - во целых бай для подсчета CRC ----
 n = _CRC_calc(_UART_TX_Buf,b);				// Считаем CRC
 _UART_TX_Buf[b++] = n & 0xFF;	  			// Пишем младший байт - вначале передаем младший байт
 _UART_TX_Buf[b++] = ((n >> 8) & 0xFF);		// Пишем старший байт - затем старший байт
 
_UART_TX_length = b;	  	  				// Запишем кол - во передаваемых байт из буфера
}

/*****************************************************************************
 Установка (Запись) в несколько дискретных выходов DO

*****************************************************************************/
void MODBUS_K15(void)
{
unsigned int n;
unsigned char b,d,c;
asm("wdr");
d = SubFunc + Data; // Считаю макс номер вывода для записи

if(d > maxAddr_DO) {m_coderr=2; return;} // Если запрашивается больше имеющихся

n = 0;
// Переписываем данные для установки выходов в int рабочий регистр
if(_UART_RX_dup[6] == 2) {n = (_UART_RX_dup[8] << 8) | _UART_RX_dup[7];}
else if(_UART_RX_dup[6] == 1) {n = _UART_RX_dup[7];}
else {m_coderr=2; return;} // не верно задано кол-во байт для записи

for(b = SubFunc,c = 0; b < d; b++) // заполняем данными флаги в регистре R_DOUT
  {
  if(((n >> c) & 0x01) != 0) OutControl(b,1); // Если проверяемый бит не = 0 - Установим соответствующий бит в регистре
  else OutControl(b,0); 	   					// если = 0 - Сбросим соответствующий бит в регистре
  c++;
  }
// *************** Теперь составим ответ **********************************
b = 0;
 _UART_TX_Buf[b++] = Address_device & 0xFF;		// Запишем адрес контроллера
 _UART_TX_Buf[b++] = Func; 						// Запишем выполненую команду
 _UART_TX_Buf[b++] = _UART_RX_dup[2];			// Запишем запрошеный адрес выхода ст. байт
 _UART_TX_Buf[b++] = _UART_RX_dup[3]; 	   		// Запишем запрошеный адрес выхода мл. байт
 _UART_TX_Buf[b++] = _UART_RX_dup[4];			// Запишем записаные данные кол-во выходов ст. байт
 _UART_TX_Buf[b++] = _UART_RX_dup[5]; 	   		// Запишем записаные данные кол-во выходов мл. байт
// ---- Подсчет CRC ----
 n = _CRC_calc(_UART_TX_Buf,b);				// Считаем CRC
 _UART_TX_Buf[b++] = n & 0xFF;	  			// Пишем младший байт - вначале передаем младший байт
 _UART_TX_Buf[b++] = ((n >> 8) & 0xFF);		// Пишем старший байт 

 _UART_TX_length = b;	  	  				// Запишем кол - во передаваемых байт из буфера
}

/*****************************************************************************
 Установка (Запись) в несколько Holding регистров (запись)
******************************************************************************
*****************************************************************************/
void MODBUS_K16(void)
{
// Внутренние переменные
unsigned int n;
unsigned char b,d,c;

asm("wdr");

d = SubFunc + Data; // Считаю макс адрес записываемого регистра
if(d > maxAddrRegHOLD) {m_coderr=2; return;} // Если запрашивается изменение регистра больше имеющихся

// --- Выполню запись в регистры  ---
for(b = SubFunc, c = 0; b < d; b++) // заполняем
 {
  MB_Hreg[b] = (_UART_RX_dup[7+(c*2)] << 8) | _UART_RX_dup[8+(c*2)]; // Это просто в Holding
  // --- Для контроллера КМ01-3200.М ---
  #ifdef _KM3200_
  if(b == 6) wr_mcnt();	// если это конфигурация счетчиков - записать новое значение в EEPROM
  else if(b == 7) wr_vcnt1();	// если это значение делителя для счетчика №1 - записать новое значение в EEPROM
  else if(b == 8) wr_vcnt2();	// если это значение делителя для счетчика №2 - записать новое значение в EEPROM
  else if(b == 9) wr_vcnt3();	// если это значение делителя для счетчика №3 - записать новое значение в EEPROM
  else if(b == 10) wr_vhcnt1();	// если это старшее опорное слово для счетчика №1 - записать новое значение в EEPROM
  else if(b == 11) wr_vlcnt1();	// если это младшее опорное слово для счетчика №1 - записать новое значение в EEPROM
  else if(b == 12) wr_vhcnt2();	// если это старшее опорное слово для счетчика №2 - записать новое значение в EEPROM
  else if(b == 13) wr_vlcnt2();	// если это младшее опорное слово для счетчика №2 - записать новое значение в EEPROM
  else if(b == 14) wr_vhcnt3();	// если это старшее опорное слово для счетчика №3 - записать новое значение в EEPROM
  else if(b == 15) wr_vlcnt3();	// если это младшее опорное слово для счетчика №3 - записать новое значение в EEPROM
  else if(b == 29) wr_adr();	// если это адрес контроллера - записать новое значение в EEPROM
  else if(b == 30) wr_par();	// если это параметры сети - записать новое значение в EEPROM
  #endif
  c++;
 }
 // ----------------- Составляем ответ ---------------------------------------------
b = 0;
 _UART_TX_Buf[b++] = Address_device & 0xFF;   // Запишем адрес контроллера
 _UART_TX_Buf[b++] = Func; 		  // Запишем выполненую команду
 _UART_TX_Buf[b++] = _UART_RX_dup[2];		  // Запишем ст. байт начального адреса регистра
 _UART_TX_Buf[b++] = _UART_RX_dup[3];		  // Запишем мл. байт начального адреса регистра
 _UART_TX_Buf[b++] = _UART_RX_dup[4];		  // Запишем ст. байт кол-ва записаных регистров
 _UART_TX_Buf[b++] = _UART_RX_dup[5];		  // Запишем мл. байт кол-ва записаных регистров
// --- Подсчет CRC ---
 n = _CRC_calc(_UART_TX_Buf,b);				// Считаем CRC
 _UART_TX_Buf[b++] = n & 0xFF;	  		  // Пишем младший байт - вначале передаем младший байт
 _UART_TX_Buf[b++] = ((n >> 8) & 0xFF);  // Пишем старший байт - затем старший байт

_UART_TX_length = b;	  	  				// Запишем кол - во передаваемых байт из буфера
}

/**************************************************************************
Ф-я обрабатывает принятый фрейм и формирует массив 
для ответа на поступивший запрос

Коды ошибок:
			00 - нет ошибки
			01 - код команды не поддерживается
			02 - неверный адрес регистра
			03 - недопустимое значение данных для записи в регистр
			04 - сбой устройства
			05 - подтверждение запроса (запрос принят и выполняется,
			     для завершения требуется время )
			06 - устройство занято предыдущим запросом
			08 - ошибка четности при обращении к регистру ???
В обработчике приняты следующие соответствия:
Адрес ответа берем из стека регистров Holding, а команду из массива принятой команды
**************************************************************************/

void MODBUS_RTU(void)
{
	/*
	buf[0]			- Адрес устройства
	buf[1]			- Код функции
	buf[2]+buf[3]		- Код подфункции (адрес элемента)
	buf[4]+buf[5]		- Данные (для функций 0x05, 0x06 записываемые данные, для 0x01-0x04 количество считываемых данных)
	buf[6]+buf[7]		- CRC свертка (контрольная сумма стандарта Modbus RTU)
	*/
unsigned int q;
asm("wdr");
// --------------- Заполню полученными данными рабочие регистры -----------------------------------------------
m_coderr = 0;											// Код ошибки изначально = 0
Func = _UART_RX_dup[1];									// Получим выполняемую комманду
SubFunc = (_UART_RX_dup[2]<<8) | _UART_RX_dup[3];		// Получим начальный адрес регистрового поля из запроса
Data = (_UART_RX_dup[4]<<8) | _UART_RX_dup[5];	// Получим кол-во запрашиваемых квантов
_UART_TX_length = 0; // Обнулю кол-во байт для передачи

if((Func == 5) || (Func == 6)) Data = 1; // --- если команда 5 или 6 то по умолчанию - количество запросов = 1

// ---------------------------- Выполним команды ---------------------------------------------------------------
//------------Проверка параметров на допустимость ---------------------
if (Data==0)	//запросили 0 квантов - для других команд кроме 5 и 6
 {
 m_coderr=3; // Установим код ошибки - неверный адрес регистра
 }/*---------------------------- k1 -----------------------------------*/	
else if (Func == 1)//чтение дискретного выхода DO[1...16]
 {
  MODBUS_K1_2();
 }	
/*---------------------------- k2 -----------------------------------*/	
else if (Func == 2)//чтение дискретного входа DI[1...16]
 {// 
 MODBUS_K1_2();  
 }	
/*---------------------------- k3 -----------------------------------*/	
else if (Func == 3)//чтение нескольких регистров Holding[1...16]
 {// 
 MODBUS_K3_4();  
 }
/*---------------------------- k4 -----------------------------------*/	
else if (Func == 4)//чтение нескольких регистров Input [1...16]
 {// 
 MODBUS_K3_4();  
 }
/*---------------------------- k5 -----------------------------------*/		
else if (Func == 5)//Установка (запись) дискретного вывода DO[1...16]
 {
 MODBUS_K5();				  
 }
/*---------------------------- k6 -----------------------------------*/		
else if (Func == 6)//Установка (запись) одного регистра Holding
 {
 MODBUS_K6();				  
 }
/*---------------------------- k15 -----------------------------------*/		
else if (Func == 15)//Установка (запись) нескольких дискретных выходов DO[1...16]
 {
 MODBUS_K15();				  
 }
/*---------------------------- k16 -----------------------------------*/	
else if (Func == 16)//Установка (запись) нескольких регистров Holding[1...16]
 {
 MODBUS_K16();				 
 }
else m_coderr=1; // Не правильно задана функция для данного контроллера (не совпала ни одна команда)

/* ------ Здесь надо составить ответ или ОШИБКА если он еще не составлен ------- */
if(m_coderr == 0)   // --- Если ошибки нет ---
 {
 if(_UART_TX_length != 0)  _UART_Go(_UART_TX_length); // и есть байты для отправки то - Активизировать порт передачи
 }
else		 	   // --- ОШИБКА - надо отослать фрейм ошибки ---
 {
  _UART_TX_Buf[0] = Address_device & 0xFF;	// Запишем адрес контроллера
  _UART_TX_Buf[1] = (Func | 0x80); 			// Запишем выполненую команду с уст. флагом ошибки
  _UART_TX_Buf[2] = m_coderr;	  			// Пишем код ошибки
  // -------------- Кол - во целых бай для подсчета CRC --------------------
  q = _CRC_calc(_UART_TX_Buf,3);		// Считаем CRC
  _UART_TX_Buf[3] = q & 0xFF;	  		// Пишем младший байт - вначале передаем младший байт
  _UART_TX_Buf[4] = ((q >> 8) & 0xFF);	// Пишем старший байт - затем старший байт
  _UART_TX_length = 5;	  	  			// Запишем кол - во передаваемых байт из буфера NetTxData
  _UART_Go(_UART_TX_length);			// Активизировать порт передачи
 }
 
}

#endif
// *********************************************************** END ***************************************************************************************