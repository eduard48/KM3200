/************************************************************************************************
* Библиотека для работы с памятью EEPROM и FLASH контроллеров KM01-3200.M0
*
*************************************************************************************************/
#ifndef _MEM_	
#define _MEM_

// --- Подключаемые библиотеки ---
#include <avr/io.h>	
#include <avr/pgmspace.h>
#include <avr/eeprom.h>

#include "km_3200.h"

// --- Объявляю структуру для памяти ---
typedef struct
{
	unsigned char Address_device;	// Адрес модуля в сети ModBus
	unsigned char COM_Speed;		// Категория скорости в сети
	unsigned char COM_Param;		// Параметры сети
	unsigned char INP_Mode;			// Режим работы цифровых входов
	unsigned char CB_cnt1;			// Значение накопительного счетчика для входа №1
	unsigned char CB_cnt2;			// Значение накопительного счетчика для входа №2
	unsigned char CB_cnt3;			// Значение накопительного счетчика для входа №3
	unsigned int HW_cnt1;			// Старшее слово начального значения для счетного входа №1
	unsigned int LW_cnt1;			// Младшее слово начального значения для счетного входа №1
	unsigned int HW_cnt2;			// Старшее слово начального значения для счетного входа №2
	unsigned int LW_cnt2;			// Младшее слово начального значения для счетного входа №2
	unsigned int HW_cnt3;			// Старшее слово начального значения для счетного входа №3
	unsigned int LW_cnt3;			// Младшее слово начального значения для счетного входа №3
	
} config;

// --------- Объявление рабочей структуры в EEPROM -------------------------------------------
config MEM EEMEM;	// Значения настроек - рабочая структура в EEPROM

// ------- Уставки контроллера по умолчанию (храняться в EEPROM) -----------------------------
config MEM_df EEMEM = 
{
	0xEF,					// Адрес модуля в сети ModBus (239)
	0x07,					// Категория скорости в сети (19200)
	0x00,					// Параметры сети (8E1)	
	0x00,					// Цифровые входы в обычном режиме (не счетные входа)
	0x01,					// входящие импульсы накапливать по 1 для входа №1
	0x01,					// входящие импульсы накапливать по 1 для входа №2
	0x01,					// входящие импульсы накапливать по 1 для входа №3
	0x0000,					// Ст опорное число = 0
	0x0000,					// Мл опорное число = 0
	0x0000,					// Ст опорное число = 0
	0x0000,					// Мл опорное число = 0
	0x0000,					// Ст опорное число = 0
	0x0000					// Мл опорное число = 0	
};

/**************** установка заводских настроек (заданных по умолчанию) ********************************************
* изначально все уставки находяться в  и переписываются в eeprom, затем из eeprom в рагистры ОЗУ
*******************************************************************************************************************/
void set_default(void)
{
config tma;		// Временный массив!
	// --- заполню массив настроек по умолчанию ---
	if(eeprom_is_ready() == 0) eeprom_busy_wait();	// Ждать готовности eeprom
	WDR();
	eeprom_read_block(&tma,&MEM_df,sizeof(MEM_df));	// Считаю вcе из EEPROM в ОЗУ
	WDR();
	if(eeprom_is_ready() == 0) eeprom_busy_wait();	// Ждать готовности eeprom
	WDR();
	eeprom_write_block(&tma,&MEM,sizeof(tma));		// Записать всю структуру ОЗУ в EEPROM структуру рабочих настроек
	
}

//================================================ Работа с INPUT регистрами ===============================================================

/************ Чтение имени контроллера из FLASH в Ireg регистр ****************************************************/
void rd_name(void)
{
for(unsigned char i=0;i<6;i++)
	{
		MB_Ireg[28+i] = (unsigned int) (pgm_read_byte(&fl_name[i*2]) << 8);
		MB_Ireg[28+i] |= pgm_read_byte(&fl_name[(i*2)+1]);
	}
}
/************ Чтение версии ПО контроллера из FLASH в Ireg регистр ***********************************************/
void rd_ver(void)
{
for(unsigned char i=0;i<3;i++)
  {
	MB_Ireg[36+i] = (unsigned int) (pgm_read_byte(&fl_version[i*2]) << 8);
	MB_Ireg[36+i] |= pgm_read_byte(&fl_version[(i*2)+1]);
  }
}
/************ Чтение серийного номера контроллера из FLASH в Ireg регистр ****************************************/
void rd_ser(void)
{
for(unsigned char i=0;i<3;i++)
  {
	MB_Ireg[39+i] = (unsigned int) (pgm_read_byte(&fl_progid[i*2]) << 8);
	MB_Ireg[39+i] |= pgm_read_byte(&fl_progid[(i*2)+1]);
  }
}
//================================================ Работа с HOLDING регистрами ===============================================================
//============================================================================================================================================

/************ Чтение адреса контроллера в ModBus сети из EEPROM в Hreg регистр ***********************************/
void rd_adr(void)
{
	if(eeprom_is_ready() == 0) eeprom_busy_wait();						// Ждать готовности eeprom
	WDR();
	MB_Hreg[29] = (unsigned int) eeprom_read_byte(&MEM.Address_device); // Считаю сетевой адрес контроллера из EEPROM в ОЗУ			
}
/*** Чтение категории скорости и параметров в сети для контроллера, из EEPROM в Hreg регистр *********************/
void rd_par(void)
{
	if(eeprom_is_ready() == 0) eeprom_busy_wait();				// Ждать готовности eeprom
	WDR();
	MB_Hreg[30] = eeprom_read_byte(&MEM.COM_Param) << 8;		// Считаю сначала параметры сети для контроллера и сдвиг т.к. это старший байт
	WDR();
	MB_Hreg[30] |= eeprom_read_byte(&MEM.COM_Speed);			// Считаю категорию скорости для контроллера и склеиваю со старшим.
}

//=====================================================================================================================================
//======================================== РАБОТА С СЧЕТНЫМИ ВХОДАМИ - ЧТЕНИЕ =========================================================

/****** Чтение значения режима работы цифровых входов контроллера из EEPROM в Hreg регистр ********************/
void rd_mcnt(void)
{
	if(eeprom_is_ready() == 0) eeprom_busy_wait();				// Ждать готовности eeprom
	WDR();
	MB_Hreg[6] = (unsigned int) eeprom_read_byte(&MEM.INP_Mode); // Считаю значение режимов работы из EEPROM в ОЗУ
}
/****** Чтение значения счетчика для входа №1 контроллера из EEPROM в Hreg регистр *****************************/
void rd_vcnt1(void)
{
	if(eeprom_is_ready() == 0) eeprom_busy_wait();				// Ждать готовности eeprom
	WDR();
	MB_Hreg[7] = (unsigned int) eeprom_read_byte(&MEM.CB_cnt1); // Считаю значение счетчика из EEPROM в ОЗУ
}
/****** Чтение младшего слова значения счетчика для входа №1 контроллера из EEPROM в Hreg регистр *************/
void rd_vlcnt1(void)
{
	if(eeprom_is_ready() == 0) eeprom_busy_wait();			// Ждать готовности eeprom
	WDR();
	MB_Hreg[11] = eeprom_read_word(&MEM.LW_cnt1);			// Считаю мл слово опорного числа счетчика из EEPROM в ОЗУ
}
/****** Чтение старшего слова значения счетчика для входа №1 контроллера из EEPROM в Hreg регистр *************/
void rd_vhcnt1(void)
{
	if(eeprom_is_ready() == 0) eeprom_busy_wait();			// Ждать готовности eeprom
	WDR();
	MB_Hreg[10] = eeprom_read_word(&MEM.HW_cnt1);			// Считаю ст слово опорного числа счетчика из EEPROM в ОЗУ
}

/****** Чтение значения счетчика для входа №2 контроллера из EEPROM в Hreg регистр *****************************/
void rd_vcnt2(void)
{
	if(eeprom_is_ready() == 0) eeprom_busy_wait();				// Ждать готовности eeprom
	WDR();
	MB_Hreg[8] = (unsigned int) eeprom_read_byte(&MEM.CB_cnt2); // Считаю значение счетчика из EEPROM в ОЗУ
}
/****** Чтение младшего слова значения счетчика для входа №2 контроллера из EEPROM в Hreg регистр *************/
void rd_vlcnt2(void)
{
	if(eeprom_is_ready() == 0) eeprom_busy_wait();			// Ждать готовности eeprom
	WDR();
	MB_Hreg[13] = eeprom_read_word(&MEM.LW_cnt2);			// Считаю мл слово опорного числа счетчика из EEPROM в ОЗУ
}
/****** Чтение старшего слова значения счетчика для входа №2 контроллера из EEPROM в Hreg регистр *************/
void rd_vhcnt2(void)
{
	if(eeprom_is_ready() == 0) eeprom_busy_wait();			// Ждать готовности eeprom
	WDR();
	MB_Hreg[12] = eeprom_read_word(&MEM.HW_cnt2);			// Считаю ст слово опорного числа счетчика из EEPROM в ОЗУ
}

/****** Чтение значения счетчика для входа №3 контроллера из EEPROM в Hreg регистр *****************************/
void rd_vcnt3(void)
{
	if(eeprom_is_ready() == 0) eeprom_busy_wait();				// Ждать готовности eeprom
	WDR();
	MB_Hreg[9] = (unsigned int) eeprom_read_byte(&MEM.CB_cnt3); // Считаю значение счетчика из EEPROM в ОЗУ
}
/****** Чтение младшего слова значения счетчика для входа №3 контроллера из EEPROM в Hreg регистр *************/
void rd_vlcnt3(void)
{
	if(eeprom_is_ready() == 0) eeprom_busy_wait();			// Ждать готовности eeprom
	WDR();
	MB_Hreg[15] = eeprom_read_word(&MEM.LW_cnt3);			// Считаю мл слово опорного числа счетчика из EEPROM в ОЗУ
}
/****** Чтение старшего слова значения счетчика для входа №3 контроллера из EEPROM в Hreg регистр *************/
void rd_vhcnt3(void)
{
	if(eeprom_is_ready() == 0) eeprom_busy_wait();			// Ждать готовности eeprom
	WDR();
	MB_Hreg[14] = eeprom_read_word(&MEM.HW_cnt3);			// Считаю ст слово опорного числа счетчика из EEPROM в ОЗУ
}
//====================================== КОНЕЦ РАБОТЫ С СЧЕТНЫМИ ВХОДАМИ ==============================================================
//=====================================================================================================================================

//------------------------------------------------------------------------------------------------------------------------- ЗАПИСЬ ---
/******************* Запись адреса контроллера в сети ModBus из Hreg в EEPROM ***********************************/
void wr_adr(void)
{
unsigned char b;
	b = (unsigned char) MB_Hreg[29];				// беру младший байт
	if(eeprom_is_ready() == 0) eeprom_busy_wait();	// Ждать готовности eeprom
	WDR();
	eeprom_write_byte(&MEM.Address_device,b);		// Записать значение в память EEPROM
}
/******************* Запись параметров сети контроллера в ModBus из Hreg в EEPROM ******************************/
void wr_par(void)
{
	unsigned char b;
	b = (unsigned char) MB_Hreg[30];				// беру младший байт
	if(eeprom_is_ready() == 0) eeprom_busy_wait();	// Ждать готовности eeprom
	WDR();
	eeprom_write_byte(&MEM.COM_Speed,b);			// Записать значение скорости в память EEPROM
	WDR();
	if(eeprom_is_ready() == 0) eeprom_busy_wait();	// Ждать готовности eeprom
	WDR();
	b = (unsigned char) (MB_Hreg[30] >> 8);			// беру старший байт
	if(eeprom_is_ready() == 0) eeprom_busy_wait();	// Ждать готовности eeprom
	WDR();
	eeprom_write_byte(&MEM.COM_Param,b);			// Записать значение параметров в память EEPROM
}

//=========================================== РАБОТА С СЧЕТНЫМИ ВХОДАМИ - ЗАПИСЬ ================================================
//===============================================================================================================================
/******************* Запись режима работы входов контроллера из Hreg в EEPROM ******************************/
void wr_mcnt(void)
{
	if(eeprom_is_ready() == 0) eeprom_busy_wait();					// Ждать готовности eeprom
	WDR();
	eeprom_write_byte(&MEM.INP_Mode,(unsigned char) MB_Hreg[6]);	// Записать значение в память EEPROM
}

/********** Запись числа пересчета для счетного входа №1 контроллера из Hreg в EEPROM *********************/
void wr_vcnt1(void)
{
	if(eeprom_is_ready() == 0) eeprom_busy_wait();					// Ждать готовности eeprom
	WDR();
	eeprom_write_byte(&MEM.CB_cnt1,(unsigned char) MB_Hreg[7]);	// Записать значение в память EEPROM
}
/*** Запись значения младшего опорного числа для счетчика №1 контроллера из Hreg в EEPROM ******************/
void wr_vlcnt1(void)
{
	if(eeprom_is_ready() == 0) eeprom_busy_wait();	// Ждать готовности eeprom
	WDR();
	eeprom_write_word(&MEM.LW_cnt1,MB_Hreg[11]);	// Записать значение в память EEPROM
}
/*** Запись значения младшего опорного числа для счетчика №1 контроллера из Hreg в EEPROM ******************/
void wr_vhcnt1(void)
{
	if(eeprom_is_ready() == 0) eeprom_busy_wait();	// Ждать готовности eeprom
	WDR();
	eeprom_write_word(&MEM.HW_cnt1,MB_Hreg[10]);	// Записать значение в память EEPROM
}

/********** Запись числа пересчета для счетного входа №2 контроллера из Hreg в EEPROM *********************/
void wr_vcnt2(void)
{
	if(eeprom_is_ready() == 0) eeprom_busy_wait();					// Ждать готовности eeprom
	WDR();
	eeprom_write_byte(&MEM.CB_cnt2,(unsigned char) MB_Hreg[8]);	// Записать значение в память EEPROM
}
/*** Запись значения младшего опорного числа для счетчика №2 контроллера из Hreg в EEPROM ******************/
void wr_vlcnt2(void)
{
	if(eeprom_is_ready() == 0) eeprom_busy_wait();	// Ждать готовности eeprom
	WDR();
	eeprom_write_word(&MEM.LW_cnt2,MB_Hreg[13]);	// Записать значение в память EEPROM
}
/*** Запись значения младшего опорного числа для счетчика №2 контроллера из Hreg в EEPROM ******************/
void wr_vhcnt2(void)
{
	if(eeprom_is_ready() == 0) eeprom_busy_wait();	// Ждать готовности eeprom
	WDR();
	eeprom_write_word(&MEM.HW_cnt2,MB_Hreg[12]);	// Записать значение в память EEPROM
}
/********** Запись числа пересчета для счетного входа №3 контроллера из Hreg в EEPROM *********************/
void wr_vcnt3(void)
{
	if(eeprom_is_ready() == 0) eeprom_busy_wait();					// Ждать готовности eeprom
	WDR();
	eeprom_write_byte(&MEM.CB_cnt3,(unsigned char) MB_Hreg[9]);	// Записать значение в память EEPROM
}
/*** Запись значения младшего опорного числа для счетчика №3 контроллера из Hreg в EEPROM ******************/
void wr_vlcnt3(void)
{
	if(eeprom_is_ready() == 0) eeprom_busy_wait();	// Ждать готовности eeprom
	WDR();
	eeprom_write_word(&MEM.LW_cnt3,MB_Hreg[15]);	// Записать значение в память EEPROM
}
/*** Запись значения младшего опорного числа для счетчика №3 контроллера из Hreg в EEPROM ******************/
void wr_vhcnt3(void)
{
	if(eeprom_is_ready() == 0) eeprom_busy_wait();	// Ждать готовности eeprom
	WDR();
	eeprom_write_word(&MEM.HW_cnt3,MB_Hreg[14]);	// Записать значение в память EEPROM
}

/*************************************** Инициализация регистров из памяти ********************************/
void InitMem(void)
{
	// Заполняю структуру регистров INPUT
	rd_name();		// Имя контроллера
	rd_ver();		// Версия ПО контроллера
	rd_ser();		// Серийный номер контроллера
	// Заполняю структуру регистров HOLD
	rd_adr();		// Адрес контроллера в сети ModBus
	rd_par();		// Параметры сети
	rd_mcnt();		// указатель режима работы цифровых входов
	rd_vcnt1();		// значение делителя для входа №1
	rd_vcnt2();		// значение делителя для входа №2
	rd_vcnt3();		// значение делителя для входа №3
	rd_vhcnt1();	// старшее слово опорного значения счетного входа №1
	rd_vlcnt1();	// младшее слово опорного значения счетного входа №1
	rd_vhcnt2();	// старшее слово опорного значения счетного входа №2
	rd_vlcnt2();	// младшее слово опорного значения счетного входа №2
	rd_vhcnt3();	// старшее слово опорного значения счетного входа №3
	rd_vlcnt3();	// младшее слово опорного значения счетного входа №3
}

#endif
//***************************************************** END ************************************************