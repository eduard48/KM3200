/********************************************************************************************************************************
 * KM_3200_v220.c
 *
 * Created: 02.12.2015 17:21:01
 *  Author: Ed
 * version: 1.00
 *
 * Программа для Блока питания модуля МM01_ver101
 * 
 ********************************************************************************************************************************/ 
/* Используемые выводы контроллера ATMEGA168PA
*
* PB0 - output LD (выход управления красным светодиодом Авария/NET на панели индикации)
* PB1 - output DO1 (реле)
* PB2 - output DO2 (реле)
* PB3 - MOSO---\
* PB4 - MOSI    | - ISP для программирования
* PB5 - SCK----/
* PB6 - кварц
* PB7 - кварц
*
* PC0 - input IN3
* PC1 - input IN2
* PC2 - input IN1
* PC3 - NC
* PC4 - NC
* PC5 - NC
* PC6 - RESET
*
* PD0 - input RX(UART) (вход RX для работы по UART (подтянут к +))
* PD1 - output TX(UART) (выход TX для работы по UART)
* PD2 - output TXE(RS485) (выход для управления направления обмена по RS485)
* PD3 - NC
* PD4 - NC
* PD5 - input JP (вход подтянут к +, используется для активизации bootloader)
* PD6 - NC
* PD7 - NC
**********************************************************************************************************************************
* Изменения в проекте 15.03.2015
* Увеличил кол-во Input и Hold регистров до 64 - лишние можно использовать в программе пользователя
* Изменил функции чтения состояния и управления дискр входами/выходами
* Изменил расположение счетных регистров (для удобства работы со SCADA)
* Убрал файл task теперь такты выполняются по таймеру 1
* 18.11.2017 Переделал моргание светодиодом - как у всех КМ
*********************************************************************************************************************************/

// --- Основные объявления ---
#define F_CPU 14745600UL 			
#define COM_RX_BUFFER_SIZE 127		
#define COM_TX_BUFFER_SIZE 127		

// --- Включаемые стандартные библиотеки ---
#include <avr/io.h>
#include <avr/eeprom.h>
#include <avr/pgmspace.h>

// --- Включаемые sem библиотеки ---
#include "km_3200.h"
#include "net.h"
#include "ioport.h"
#include "mem.h"

//------------------- Сообщение компилятора (для информации) -----------------------
#ifdef	_KM3200_
#warning "MESSAGE - Select type device - KM01-3200.M ver.0220"
#endif
//================== Работа с собачьм таймером ======================================
/* На будущее
void InitWdt(void)
{
	MCUSR &= ~(1<<WDRF); 			// д.б. сброшен (если = 1, то и WDE = 1 !!!)
	asm("wdr");						// сброс счетчика WDT
	WDTCSR |= (1<<WDE)|(1<<WDCE);	// для сброса WDE - надо делать так!
	WDTCSR = 0x0F;					// 2 сек и разрешен сброс по тайм ауту
}
*/
// ============ takt_timer выполняется по прерыванию каждые 10 мсек =================
void takt_timer(void)
{  unsigned char n;
	n = TimerTakt;
	if (n) TimerTakt = --n;		// Время выполнения основного цикла
	n = TimerLed;
	if (n) TimerLed = --n;		// Уменьшить счетчик
}
// ============ Обработка прерывания таймера 1 (каждые 10 мсек) =====================
ISR(TIMER1_OVF_vect)
{
	TCNT1H = 0xFF;
	TCNT1L = 255 - 144;
	takt_timer();
}
//=========================== Функция инициализации ядра ============================
void Init(void)
{
unsigned char i;

	_delay_ms(500);		// Задержка при старте
	InitLine();			// Настраиваю порты контроллера
//	InitWdt();			// Настройка сторожевого таймера (пока в резерве)
	LD_on;				// Включить красный светодиод
	WDR();				// Сброс собачьего таймера
	_delay_ms(500);		// Задержка при старте
	for(i=0; i<maxAddrRegINP; i++) { MB_Ireg[i] = 0; }	// Очистить INPUT регистры
	for(i=0; i<maxAddrRegHOLD; i++) { MB_Hreg[i] = 0; }	// Очистить HOLD регистры
	_delay_ms(100);		// Задержка
	WDR();				// Сброс собачьего таймера
	if((PIND & 0x20) == 0) 
		{ 
			set_default(); 
			for(i=0; i<5; i++) // Моргнуть 5 раз!
			{
			LD_on; 
			_delay_ms(100); 
			LD_off; 
			_delay_ms(100); 
			}
		}
	WDR();						// Сброс собачьего таймера
	InitMem();					// Заполняю регистры Модбас данными из памяти
	CNT_clear();				// Очистить счетные регистры
	WDR();						// Сброс собачьего таймера
	InitDev();					// Инициализация внутренних систем контроллера
	LD_off;						// Выключить красный светодиод
	WDR();						// Сброс собачьего таймера
	_delay_ms(1000);			// Задержка
	WDR();						// Сброс собачьего таймера
	INP_Read();					// Считываю текущие состояния входов
	COM_Init((char) MB_Hreg[30],(char) (MB_Hreg[30] >> 8)); // Настраиваю UART0 для работы RS-485
	Address_device = (char) MB_Hreg[29];					// Переписываю адрес контроллера в сети ModBus
	// ----- Настраиваю работу таймера №1 ----
	TCCR1B = (1 << CS12)|(1<< CS10);	// Timer1 / 1024 - делим тактовую на 1024
	TCNT1H = 0xFF;
	TCNT1L = 255 - (F_CPU / 1024 / 100);	// Прерывания каждые 10мсек!
	TIMSK1 |= (1<<TOIE1);					// Включить прерывания Timer 1 при переполнении
}

// =========================== Команда перезагрузки контроллера ====================================================
void command_reboot(void)
{
//if((MB_Hreg[63] &0x01) != 0) {cli(); while(1);} // Перезагрузка по сбросу собачьего таймера (пока в резерве)
if((MB_Hreg[31] &0x01) != 0) { _delay_ms(20); asm("rjmp restart;");} // Если есть 1 то перейти на метку перезагрузки
}

int main(void)
{
	// --- Инициализация ---
	cli();
	_delay_ms(500);	// Задержка при старте
asm("restart:");	// Метка для перехода по команде перезагрузки
	Init();			// Инициализация системы...
	sei();			// Разрешить глобальные прерывания	
	TimerTakt = 10; // Задачу выполнять каждые 100мсек
	while(1)
	{
	WDR(); // Сброс собачьего таймера
		if(Read_Modbus() == 1)	{TimerLed = 10; MODBUS_RTU();}	// Если пакет принят, обработать принятый пакет ModBus
		if(TimerLed) LD_on; else LD_off; // включить светодиод на 100мсек - принят пакет с адресом модуля
		if(TimerTakt == 0)
		{
			TimerTakt = 10; // Перезагрузка таймера - следующее выполнение программы через 10*10=100мсек
			// --- Состояния входов в рег Input меняются по прерываниям ---
			OUT_Read();			// Чтение состояния выходов
			//******************Здесь м.б. программа пользователя***********************************
			
			//**************************************************************************************
			OUT_Update();		// Обновить состояние дискретных выходов
			rd_cnt();			// Обновить показания счетчиков
			command_reboot();	// Проверить команду - не пора ли перезагрузиться???
			// === Формирую слово жизни контроллера ===
			if(MB_Ireg[0] <= 0xFFFA) MB_Ireg[0]++;
			else MB_Ireg[0] = 0;
		}
	}
}

//***************************************************************************** END ********************************************************************************